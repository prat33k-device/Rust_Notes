
# Linear

1. Dynamic Array
2. Singly Linked List
3. Doubly Linked List
4. Circular Linked List
5. Stack (array + linked-list versions)
6. Queue (simple, circular)
7. Deque (double-ended queue)

# Hash Based

1. HashMap
2. HashSet
3. Ordered HashMap

# Heap

1. BinaryMinHeap
2. BinaryMaxHeap
3. PriorityQueue
4. BinomialHeap
5. FibonacciHeap
6. PairingHeap

# Tree

1. BinaryTree
2. NaryTree
3. BinarySearchTree (BST)
4. Balanced BSTs
	1. AVLTree
	2. RedBlackTree
	3. (Optional) Treap
	4. (Optional) SplayTree
5. B-Tree Family (big in databases)
	1. B- Tree
	2. B+ Tree
6. Trie (Prefix Tree)
7. (Optional) Radix Tree / Patricia Trie
8. Segment Tree (also checkout lazy propagation)
9. Fenwick Tree (Binary Indexed Tree)
10. Interval Tree
11. Order Statistic Tree (BST + subtree sizes)

# Graph

1. Representations
	1. Adjacency List
	2. Adjecency Matrix
	3. Edge List
2. Disjont Set Union (Union-Find)
3. (Optional) Dynamic Graphs

# String or Text Related

1. Suffix Array
2. Suffix Tree
3. LCP Array
4. (Optional)  Aho-Carasick Automation
5. (Optional)  Rolling hash structures (for substring queries)

# Range / Query (competitive programming)

1. Sparse Table (static RMQ)
2. Monotonic Stack
3. Monotonic Queue
4. Cartesian Tree
5. Bitset tricks / bit vectors (depending on language)

***

# Cache

1. LRU Cache (hash map + doubly linked list)
2. LFU Cache
3. (Optional) ARC / CLOCK (OS-style)

# Concurrency-friendly (Very Advanced)

1. Lock-free queue (e.g., Michael–Scott queue)
2. Concurrent hash map (segmented locks / lock-free variants)
3. Ring buffer (SPSC, MPSC variants)

# Spatial / geometric (advanced)

1. k-d Tree
2. QuadTree / Octree
3. R-Tree
4. (Optional) Voronoi / Delaunay helpers (more algorithms than DS)

# Probabilistic / randomized structures (advanced, practical)

1. Bloom Filter
2. Count–Min Sketch
3. Skip List
4. (Optional) Cuckoo Hashing
5. (Optional) HyperLogLog (cardinality estimation)